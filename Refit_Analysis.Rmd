---
title: "Untitled"
author: "Andrew Maloney"
date: "6/7/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
#Loading Packages
#Will most likely add more
library(dplyr)
library(bulletxtrctr)
library(x3ptools)
library(randomForest)
library(ggplot2)
library(readr)
library(furrr)
library(stringr)
library(dichromat)
library(future)
library(gridExtra)
library(tidyr)
options(future.globals.maxSize = 4*1024*1024*1024)
#data_dir <- "/media/Raven/REU_Refit"
```

```{r}
# Reading in Hamby_173
df <- tibble(path = list.files(path = "Hamby_173", 
                               pattern = ".x3p", recursive = T, 
                               full.names = T)) %>% 
  mutate(Barrel = str_extract(path, "(Unknown|Barrel)\\d{0,2}") %>% 
           str_remove("Barrel"), 
         Bullet = str_extract(path, "Bullet[12A-Z]") %>% 
           str_remove("Bullet"),
         Land = str_extract(path, "land\\d{1}") %>% 
           str_remove("land")) %>% 
  mutate(Set = "Hamby173") %>%
  mutate(x3p = future_map(path, read_x3p)) %>%
  # Adjust orientation
# I rewrote this so it's a bit clearer. The ~ notation in purrr is pretty concise - no need to define new functions inline.
  mutate(x3p = future_map(x3p, ~x3p_m_to_mum(.) %>% y_flip_x3p()))

# Reading in Hamby_252
df2 <- tibble(path = list.files(path = "Hamby_252", 
                                pattern = ".x3p", recursive = T, 
                                full.names = T)) %>% 
  mutate(Barrel = str_extract(path, "(Unknown|Barrel)\\d{0,2}") %>% 
           str_remove("Barrel"), 
         Bullet = str_extract(path, "Bullet[12A-Z]") %>% 
           str_remove("Bullet"), 
         Land = str_extract(path, "Bullet [12A-Z]-[123456]") %>% 
           str_remove("Bullet [12A-Z]-")) %>% 
  mutate(Set = "Hamby252") %>%
  mutate(x3p = future_map(path,read_x3p))  %>%
  # Adjust orientation
  mutate(x3p = future_map(x3p, ~x3p_m_to_mum(.) %>% rotate_x3p(angle = -90) %>% y_flip_x3p()))
# One big data set - easier to debug the code if you do everything in one big go.
hamby <- bind_rows(df, df2) 
hamby <- hamby %>%
  mutate(id = paste(Set, Barrel, Bullet, Land, sep = "-")) %>%
  select(id, Set, Barrel, Bullet, Land, x3p, path)
rm(df, df2)
```

#Cross Sections look good.  Barrel Unknown Bullet B has a pretty high CrossSection of 400
```{r}
plan(multicore) # use all the cores at once
hamby <- hamby %>%
  mutate(
    CrossSection = future_map_dbl(x3p, x3p_crosscut_optimize, minccf = 0.9, span = 0.3, percent_missing = 25)
  )
head(select(hamby, -path, -x3p), 5)
#hamby %>% arrange(desc(CrossSection))

```

```{r}
#Cross Sections
hamby <- hamby %>% 
  mutate(CrossCut = future_map2(.x = x3p, .y = CrossSection, .f = x3p_crosscut))
crosscuts <- select(hamby, -path, -x3p) %>% 
  tidyr::unnest(CrossCut)
```

# For Hamby173 barrels 1, 2, and 4 for bullet 1 seem to have higher crosscut values plotted.  For Hamby173 barrel 1, bullet 2 seems to have a higher crosscut values plotted. There doesn't seem to be any noticeably low values for Hamby173.

# For Hamby 252 barrel 10 and 2, bullet 1 has high crosscut values plotted.  There also seems to be some low crosscut values plotted as well. 

```{r}
#Looking at CrossCuts to see any issues

crosscuts %>%
  filter(Barrel != "Unknown" & Set == "Hamby173") %>% 
ggplot(data = ., aes(x = x, y = value, color = Land)) + 
  geom_line() + 
  facet_grid(Set + paste("Bullet", Bullet) ~ sprintf("Barrel %02s", Barrel))

crosscuts %>%
  filter(Barrel != "Unknown" & Set == "Hamby252") %>% 
ggplot(data = ., aes(x = x, y = value, color = Land)) + 
  geom_line() + 
  facet_grid(Set + paste("Bullet", Bullet) ~ sprintf("Barrel %02s", Barrel))

crosscuts %>% 
  filter(Set == "Hamby173" & Barrel == "Unknown") %>%
  ggplot(aes(x = x, y = value)) + 
  geom_line() +
  facet_grid(Bullet~Land, labeller="label_both") +
  theme_bw()+ ggtitle("Barrel 1")

crosscuts %>% 
  filter(Set == "Hamby252" & Barrel == "Unknown") %>%
  ggplot(aes(x = x, y = value)) + 
  geom_line() +
  facet_grid(Bullet~Land, labeller="label_both") +
  theme_bw()+ ggtitle("Barrel 1")


```

#### Groved Data taken from github

```{r}
#Grooves
saved_grooves_location <- "V2H173_H252_Grooves_data.rda" # .rda file seems to be created with later version of R
if (file.exists(saved_grooves_location)) {
  hamby$Grooves <- readRDS(saved_grooves_location)
} else {
  hamby <- hamby %>% 
    mutate(Grooves = CrossCut %>% 
             future_map(.f = cc_locate_grooves, 
                        method = "rollapply", smoothfactor = 15, return_plot = T))  # use plot so that the shiny app works...
}
grooves <- hamby %>% tidyr::unnest(Grooves)
head(grooves, 10)
head(select(hamby, -path, -x3p, -CrossCut), 5)
# Need to check the grooves and set manually for now...
plan(sequential) # stop furrr multicore processes - messes with shiny/rmd
```

### Examining Groove Cut Offs
######Same as rollapply? Do not think Grooves file loaded.

```{r}

Hamby_test <- hamby %>% filter(Set == "Hamby252") %>% filter(Barrel == 6)
head(Hamby_test)

Hamby_test2 <- hamby %>% filter(Set == "Hamby252") %>% filter(Barrel == 3 & Bullet == 1)

Hamby_test3 <- hamby %>% filter(Set == "Hamby252") %>% filter(Barrel == 1 & Bullet == 1)

Hamby_test4 <- hamby %>% filter(Set == "Hamby252") %>% filter(Barrel == 9 & Bullet == 2)

Hamby_test5 <- hamby %>% filter(Set == "Hamby252") %>% filter(Barrel == "Unknown") %>% filter(Bullet == "B" | Bullet == "S" | Bullet == "U")

Hamby_test6 <- hamby %>% filter(Set == "Hamby173") %>% filter(Barrel == 3 & Bullet == 2)

Hamby_test7 <- hamby%>% filter(Set == "Hamby173") %>% filter(Barrel == "Unknown") %>% filter(Bullet == "B" | Bullet == "E" | Bullet == "U")


gridExtra::grid.arrange(Hamby_test$Grooves[[1]]$plot,
                        Hamby_test$Grooves[[7]]$plot,
                         Hamby_test2$Grooves[[4]]$plot,
                         Hamby_test3$Grooves[[6]]$plot,
                         Hamby_test4$Grooves[[4]]$plot,
                         Hamby_test5$Grooves[[2]]$plot,
                         Hamby_test5$Grooves[[10]]$plot,
                        nrow = 2)
                        
                        

                        
gridExtra::grid.arrange(Hamby_test6$Grooves[[1]]$plot,
                        Hamby_test7$Grooves[[3]]$plot,
                        Hamby_test7$Grooves[[15]]$plot,
                        Hamby_test7$Grooves[[12]]$plot,
                        nrow = 2)

rm(Hamby_test, Hamby_test2, Hamby_test3, Hamby_test4, Hamby_test5, Hamby_test6, Hamby_test7 )
```


# When run in interactive mode, a shiny app can be used to set smarter grooves.
# Grooves taken from github. Played around with shiny but did not use.
```{r get-grooves-interactive, echo = FALSE}
library(shiny)
if (file.exists(saved_grooves_location)) {
  hamby$Grooves <- readRDS(saved_grooves_location)
}
if (interactive()) { # only run when you're manually running chunks... don't run when the whole document is compiled.
  shinyApp(
    ui = fluidPage(
      selectInput("k", "Investigate kth plot:",
                  selected = 1,
                  choices = (1:length(hamby$Grooves)) %>% set_names(hamby$id)
      ),
      textOutput("groovelocations"),
      actionButton("confirm", "Confirm"),
      actionButton("save", "Save"),
      plotOutput("groovePlot", click = "plot_click"),
      verbatimTextOutput("info")
    ),
    
    server = function(input, output, session) {
      output$groovePlot <- renderPlot({
        k <- as.numeric(input$k)
        p <- hamby$Grooves[[k]]$plot
        
        p
      })
      output$groovelocations <- renderText({
        paste(
          "Left Groove: ", hamby$Grooves[[as.numeric(input$k)]]$groove[1],
          " Right Groove: ", hamby$Grooves[[as.numeric(input$k)]]$groove[2]
        )
      })
      observeEvent(input$confirm, {
        cat(paste(hamby$id[as.numeric(input$k)], "\n"))
        updateSelectInput(session, "k", "Investigate kth plot:",
                          selected = as.numeric(input$k) + 1,
                          choices = (1:length(hamby$Grooves)) %>% set_names(hamby$id)
        )
      })
      observeEvent(input$save, {
        saveRDS(hamby$Grooves, file = saved_grooves_location)
        message("groove data saved\n")
      })
      
      observeEvent(input$plot_click, {
        k <- as.numeric(input$k)
        xloc <- input$plot_click$x
        
        gr <- hamby$Grooves[[k]]$groove
        if (abs(gr[1] - xloc) < abs(gr[2] - xloc)) {
          hamby$Grooves[[k]]$groove[1] <<- xloc
        } else {
          hamby$Grooves[[k]]$groove[2] <<- xloc
        }
        output$groovePlot <- renderPlot({
          k <- as.numeric(input$k)
          p <- hamby$Grooves[[k]]$plot +
            geom_vline(xintercept = hamby$Grooves[[k]]$groove[1], colour = "green") +
            geom_vline(xintercept = hamby$Grooves[[k]]$groove[2], colour = "green")
          
          p
        })
      })
      output$info <- renderText({
        paste0("x=", input$plot_click$x, "\ny=", input$plot_click$y)
      })
    },
    options = list(height = 500)
  )
  saveRDS(hamby$Grooves, file = saved_grooves_location)
} else {
  if (!file.exists(saved_grooves_location)) {
    message("run script in interactive mode to fix grooves")
  } else {
    hamby$Grooves <- readRDS(saved_grooves_location)
  }
} 
```

```{r}
#Signatures
hamby <- hamby %>% mutate(Signatures = future_map2(.x = CrossCut, .y = Grooves, .f = cc_get_signature, span = 0.75, span2 = .03)) 
Signatures <- hamby %>% select(id, Set, Barrel, Bullet, Land, Signatures) %>% tidyr::unnest()
head(Signatures, 5)
#head(Grooves_252, 1000)
```

## Signature comparisons between Bullet 1 and Bullet 2. Looking for noticeable differences.
```{r}
#Looking for major issues - grooves not set correctly (large deviations at beginning or end of a line)
Signatures %>%
  filter(Barrel != "Unknown") %>% 
ggplot(data = ., aes(x = x, y = sig, color = Land)) + 
  geom_line() + 
  facet_grid(Set + paste("Bullet", Bullet) ~ sprintf("Barrel %02s", Barrel))# put the barrels in the right order

Signatures %>% 
  filter(Barrel == 1) %>% 
    filter(Set == "Hamby173") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet)+ theme_bw()

Signatures %>% 
  filter(Barrel == 9) %>% 
    filter(Set == "Hamby173") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet) + theme_bw()

Signatures %>% 
  filter(Barrel == 10) %>% 
    filter(Set == "Hamby173") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet) + theme_bw()

#-------------------------------------------------------------------------------------------------------
Signatures %>% 
  filter(Barrel == 1) %>% 
    filter(Set == "Hamby252") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet) + theme_bw()

Signatures %>% 
  filter(Barrel == 6) %>% 
    filter(Set == "Hamby252") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet) + theme_bw()

Signatures %>% 
  filter(Barrel == 10) %>% 
    filter(Set == "Hamby252") %>%
      ggplot(aes(x = x, y = sig, color = id))+
        geom_line() + facet_wrap(~Bullet) + theme_bw()
#qplot(data = filter(Signatures, id %in% unique(id)[1:6]), x = x, y = sig, geom = "line", color = id) # Plot a few to see what they look like



```

```{r}
comparisons <- crossing(Bullet1 = hamby$id, Bullet2 = hamby$id) %>%
  left_join(nest(hamby, -id) %>% magrittr::set_names(c("Bullet1", "Bullet1_data"))) %>%
  left_join(nest(hamby, -id) %>% magrittr::set_names(c("Bullet2", "Bullet2_data"))) %>%
  mutate(Set1 = str_extract(Bullet1, "Hamby\\d{2,3}"),
         Set2 = str_extract(Bullet2, "Hamby\\d{2,3}")) %>%
  filter(Set1 == Set2) %>% # Get rid of cross-set comparisons for now...
  select(-matches("Set"))
head(comparisons)
```

```{r}
#plan(multicore(workers = availableCores(constraints = 8)))

get_sig <- function(data) {
  purrr::map(data$Signatures, "sig")
}
comparisons <- comparisons %>%
  mutate(sig1 = purrr::map(Bullet1_data, get_sig), sig2 = purrr::map(Bullet2_data, get_sig))
plan(multicore)
comparisons <- comparisons %>%
  mutate(Aligned = future_map2(sig1, sig2, ~sig_align(unlist(.x), unlist(.y))))
# Get striae
comparisons <- comparisons %>%
  mutate(Striae = future_map(Aligned, sig_cms_max))
saveRDS(select(comparisons, -Bullet1_data, -Bullet2_data), file = "Hamby_173_252_Comparisons.rda")

```

```{r}
comparisons <- comparisons %>% 
  select(-Bullet1_data, -Bullet2_data)

plan(multicore(workers = availableCores(constraints = 8)))

comparisons <- comparisons %>% 
  mutate(features = future_map2(.x = Aligned, .y = Striae, .f = extract_features_all, resolution = 1.5625))

comparisons <- comparisons %>% 
  mutate(Legacy_Features = future_map(Striae, extract_features_all_legacy, resolution = 1.5625))

comparisons <- comparisons %>% 
  tidyr::unnest(Legacy_Features)

head(comparisons)
```


##### Creating Columns for organization and for future plotting purposes.
```{r}
comparisons <- tibble::rowid_to_column(comparisons, "Index")

comparisons <- comparisons %>% 
  mutate(Set = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\1", Bullet2))
comparisons <- comparisons %>% 
  mutate(BarrelA = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\2", Bullet2))
comparisons <- comparisons %>% 
  mutate(BarrelB = gsub("(Hamby173|Hamby252)-([0-9]{0,2}|Unknown)-([1-2A-Z])-([1-6])", "\\2", Bullet1))
comparisons <- comparisons %>% 
  mutate(BulletA = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\3", Bullet2))
comparisons <- comparisons %>% 
  mutate(BulletB = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\3", Bullet1))
comparisons <- comparisons %>% 
  mutate(LandA = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\4", Bullet2))
comparisons <- comparisons %>% 
  mutate(LandB = gsub("(Hamby173|Hamby252)-([0-9]{1,2}|Unknown)-([1-2A-Z])-([1-6])", "\\4", Bullet1))

head(comparisons, 50)

```


##Looking at the summary statistics for some of the features extracted we can see important observations. The ccf has a minimum value of .0489, a mean of .3577, and a Maximum value of 1.  For Consecutively Matching Striae we see a minumum value of 0, a mean of 1.049, and a Maximum of 15.9357.  For non Consecutively Matching Striae we see a minimum value of 0, a mean of 6.135, and a maximum of 20.408. For # matches we have a minimum value of 0, a mean of 1.611, and a maximum of 15.9357. For # mismatches we have a minimum value of 0, a mean of 10.390, and a maximum of 20.408.  For average Distance (D) we have a minimum value of 0, a mean of .003341, and a maximum value of .02. For sum_peaks we have a minimum value of 0, a mean of 2.921, and a maximum of 44.036. 

### Based on these summary statistics there are a few concerns with the data. The values given for cms, non_cms, mismatches, and D are very low.  The statistics for D seem extremely low and are not making a lot of sense.

#### We now create a density plot.  First we had to define a "Known Match" and a "Known non Match."  Standard procedure for a "Known" match/nonmatch is if the ccf is greater than or equal to 50, then it is a Known match.  If the ccf is less than 50, it is a known nonmatch.  From the Density plot, the first things that strike concerns are the scaling of the x and y axes.  The second thing to notice is that seperation in the density plots only starts to occur when the ccf condition for a Known match/nonmatch increases from 50 to around 70 and up.  


```{r}
comparisons %>% select(ccf, cms, non_cms, matches, mismatches, D, sum_peaks) %>% summary()

comparisons <- comparisons %>% 
  mutate(KM_KNM = if_else(ccf >= 0.75, "Known_Match", "Known_non_Match")) %>% 
    mutate(KM_KNM = factor(KM_KNM))

HambyDataLong <- gather(comparisons, key="measure", value="value", c("ccf", "cms", "non_cms", "matches", "mismatches", "D", "sum_peaks"))

HambyDataLong %>% 
    ggplot(aes(value, fill = KM_KNM))+
      geom_density(position = "identity", alpha = 0.50)+
        facet_wrap(~measure, ncol = 4, scale = "free")+
          scale_fill_brewer(palette = "Paired") + theme_bw()+
            ggtitle("Marginal Density for Features")

head(HambyDataLong)

rm(HambyDataLong) # File size is large, just for  convenience sake.

```



